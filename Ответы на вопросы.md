### Николаева Ксения, 9 группа, вариант 1

### Нулевая группа вопросов

#### 1. Win API, необходимое для Лабораторной работы №3

Для решения ЛР №3, связанной с синхронизацией потоков, используются следующие функции Windows API:

- **Создание и управление потоками**:
  ```c
  HANDLE CreateThread(
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      SIZE_T dwStackSize,
      LPTHREAD_START_ROUTINE lpStartAddress,
      LPVOID lpParameter,
      DWORD dwCreationFlags,
      LPDWORD lpThreadId
  );
  ```
  - Используется для создания потоков `marker`.

- **Синхронизация через события**:
  ```c
  HANDLE CreateEvent(
      LPSECURITY_ATTRIBUTES lpEventAttributes,
      BOOL bManualReset,
      BOOL bInitialState,
      LPCSTR lpName
  );
  BOOL SetEvent(HANDLE hEvent);
  BOOL ResetEvent(HANDLE hEvent);
  DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
  ```
  - Применяется для координации работы `main` и `marker`, передачи сигналов о невозможности продолжения работы и завершении потока.

- **Завершение потоков**:
  ```c
  BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode);
  BOOL CloseHandle(HANDLE hObject);
  ```
  - Позволяет корректно завершать `marker`.

Пример использования `WaitForSingleObject`:
```c
WaitForSingleObject(hEvent, INFINITE);
```
Этот вызов блокирует `main`, пока событие `hEvent` не будет установлено в сигнальное состояние потоком `marker`.

#### 2. Что такое поток в ОС Windows?

Поток (thread) — это минимальная исполняемая единица в ОС Windows. Он выполняется в рамках процесса и обладает:

- кодом исполняемой функции,
- стеком,
- контекстом процессора,
- блоком окружения.

Типы потоков:
- **Рабочие потоки** (working threads) — выполняют фоновые задачи.
- **Потоки интерфейса** (UI threads) — отвечают за обработку сообщений окон.

Пример создания потока:
```c
HANDLE hThread = CreateThread(NULL, 0, ThreadFunc, NULL, 0, NULL);
```

#### 3. Что такое мьютекс?

Мьютекс (mutex) — это объект синхронизации, позволяющий ограничить доступ к общему ресурсу.

Пример использования:
```c
HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
WaitForSingleObject(hMutex, INFINITE);
ReleaseMutex(hMutex);
```

#### 4. Что такое событие (объект синхронизации)?

Событие (event) — это объект, сигнализирующий о выполнении определенного условия.

Пример:
```c
HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
SetEvent(hEvent); // Устанавливает событие в сигнальное состояние
WaitForSingleObject(hEvent, INFINITE);
```

#### 5. Сравнительный анализ C++98 и более новых стандартов (C++11)

**Основные различия:**
| Особенность | C++98 | C++11 |
|------------|--------|---------|
| Потоки | Нет встроенной поддержки | `std::thread`, `std::mutex` |
| Лямбда-выражения | Нет | Поддерживаются |
| `auto` | Нет | Поддерживается |
| `nullptr` | `NULL` | `nullptr` |
| `std::shared_ptr`, `std::unique_ptr` | Нет | Поддерживаются |

Пример `std::thread` в C++11:
```cpp
#include <thread>
void func() { /* код */ }
std::thread t(func);
t.join();
```

Использование `std::mutex` вместо `CreateMutex` в C++11:
```cpp
std::mutex mtx;
mtx.lock();
// критическая секция
mtx.unlock();
```

Эти улучшения упрощают многопоточность по сравнению с WinAPI.

---

### Общие вопросы

#### 1. Что такое ООП?
Объектно-Ориентированное Программирование (ООП) — это парадигма программирования, основанная на концепции объектов, которые инкапсулируют состояние (данные) и поведение (методы). Основные принципы ООП:
- **Инкапсуляция** — объединение данных и методов в один объект.
- **Наследование** — способность объекта наследовать свойства и методы другого объекта.
- **Полиморфизм** — возможность использования одного интерфейса для различных реализаций.
- **Абстракция** — выделение ключевых характеристик объекта без учета незначительных деталей.

Пример ООП на C++:
```cpp
class Car {
private:
    string model;
public:
    Car(string m) : model(m) {}
    void drive() { cout << "Driving " << model << endl; }
};
```

#### 2. Магическое число 7 Миллера
Это ограничение кратковременной памяти человека, которое гласит, что среднестатистический человек может удерживать в уме от 5 до 9 элементов одновременно.

Примеры в IT:
1. Количество элементов в интерфейсе пользователя.
2. Длина номеров телефонов.
3. Число вкладок, комфортных для восприятия в браузере.
4. Размер списка задач в agile.
5. Ограничение количества параметров функции.
6. Количество уровней вложенности в коде.
7. Число процессов в сознании программиста одновременно.

#### 3. Энтропия ПО
Энтропия программного обеспечения — это мера его сложности и неупорядоченности, увеличивающаяся со временем без рефакторинга.

Негэнтропийные меры:
1. Четкая архитектура (MVC, MVVM, Clean Architecture).
2. Автоматизированное тестирование (юнит-тесты, интеграционные тесты).
3. Использование стандартов кодирования.
4. Документирование кода и требований.
5. CI/CD для упрощения развертывания.

#### 4. 5 признаков сложной системы по Гради Бучу
1. **Иерархичность**
   - Пример: Многоуровневая архитектура ПО (например, клиент-серверная модель).
   - Пример: Разделение на модули в проекте `car_owners_project`.

2. **Эмерджентность**
   - Пример: Взаимодействие потоков в `znak_project` приводит к непредсказуемому поведению.
   - Пример: Динамическое формирование интерфейса на основе данных в HTML-проекте.

3. **Абстракция**
   - Пример: Использование `interface.h` в проектах для скрытия реализации.
   - Пример: Определение базовых классов в ООП.

4. **Множественность представлений**
   - Пример: Разные уровни логирования системы (debug, info, error).
   - Пример: Разные визуальные представления данных в HTML-верстке.

5. **Эволюция**
   - Пример: Постепенное усложнение `znak_project` через рефакторинг и тестирование.
   - Пример: Постепенное развитие SQL-запросов в упражнениях с SQLite.

#### 5. Закон иерархических компенсаций Седова
Этот закон утверждает, что усложнение одной части системы ведет к упрощению другой.

Примеры в IT:
1. Рост абстракций в языках программирования (C → C++ → Python).
2. Появление фреймворков (Spring, Django) для упрощения работы с кодом.
3. Развитие виртуальных машин (JVM, .NET) для повышения переносимости.
4. Облачные вычисления заменяют сложные локальные серверные конфигурации.
5. Автоматизированные тесты уменьшают потребность в ручном тестировании.


